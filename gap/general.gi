###################################################################
# Given a set of vector and a basis of a vector space returns
# a basis of the vector space generated by all
###################################################################
InSpan := function( vecs, span )

    local   basis,
            tmp,
            vec;

    if not IsMatrix( vecs ) then return InSpan( [vecs], span ); fi;

    if IsEmpty( span ) then
        basis := [ ZeroVector( Length(vecs[1]), vecs[1] ) ];
    else
        basis := StructuralCopy( span );
    fi;

    tmp := StructuralCopy( basis );
    for vec in vecs do
        Add( tmp, vec );
         if RankMat( basis ) <> RankMat( tmp ) then 
            Add( basis, vec );
            tmp := StructuralCopy( basis );
        fi;
    od;
    TriangulizeMat(basis);

    return Filtered( basis, x -> x*0 <> x );

end;

####################################################
# Given a vector and a basis of a vector space 
# returns a boolean that asserts if the given vector
# is in the generated vector space
####################################################
IsInSpan := function( vec, span )

    local   tmp, basis;

    if IsEmpty( span ) then
        basis := [ ZeroVector( Length(vec), vec ) ];
    else
        basis := StructuralCopy( span );
    fi;

    tmp := ShallowCopy( basis );
    Add( tmp, vec );
    if RankMat( basis ) <> RankMat( tmp ) then 
        return false;
    else
        return true;
    fi;

end;

RecoverMatrixByVector := function( v, d )
    return List( [1..d], x -> v{[(x-1)*d+1..x*d]} );
end;

MatrixMultFlat := function( v, w, d )
    local   A,B;

    A := RecoverMatrixByVector( v, d );
    B := RecoverMatrixByVector( w, d );

    return( Flat( A*B ) );

end;

##########################################
# Returns whether a matrix is semisimple 
# or not
##########################################
IsSemisimpleMatrix := function( A )
    local   f;

    f := MinimalPolynomial( A );
    f := Collected( Factors(f) );

    return not ForAny( f, x -> x[2] > 1 );

end;

#########################################################
# Given a set of matrices returns if all commute
#########################################################
IsAbelianMatrixAction := function( mats )
    local   i,j,
            comm;

    comm := [];

    for i in [ 1..Length(mats)-1 ] do
        for j in [ i..Length(mats) ] do
            Add( comm, mats[i]*mats[j]-mats[j]*mats[i] );
        od;
    od;

    return ForAll( comm, x -> x = x*0 );

end;

###################################################################
# Given a set of matrices returns if all are semisimple and commute
###################################################################
IsSemisimpleAbelianMatrixGroup := function( mats )
        if not IsAbelianMatrixAction( mats ) then return false; fi;
        return ForAll( mats, x -> IsSemisimpleMatrix( x ) );
end;

##################################################
# Given a list [s1, s2, ..., s_l] and an integer n
# returns sum( s_n, ... , s_l ) 
##################################################
SumOfSplitting := function( split, n )
    local   tmp;

    tmp := split{[n .. Length(split) ]}; 
    tmp := Concatenation( tmp );

    return VectorspaceBasis( tmp );
end;

###############################################################
# Given a matrix computes a diagonal matrix of the denominators
###############################################################
DenominatorMat := function( A )
    local rr;

    rr := List( A , x -> List( x, y -> DenominatorRat( y ) ) );
    rr := List( rr, x -> Lcm( x ) );

    return DiagonalMat( rr );

end;