#############################################
# Auxiliar funtion to multiply two lists
#############################################
OrStABProductTwoLists := function( l1, l2 )

    local   i,j,
            l,
            e;

    l := []; e:= [];
    for i in [1..Length( l1 ) ] do
        for j in [1..Length( l2 ) ] do
            Add( l, l1[i]*l2[j] );
            Add( e, [i,j] );
        od;
    od;

    return rec( prod := l, e := e );

end;

##########################################################
# Auxiliar funtion to multiply a list of lists
##########################################################
OrStABProductListOfLists := function( l )

    local   prod,
            e,
            i,j,
            tmp;

        prod := l[1];
        e    := [1..Length( l[1] ) ];
        for i in [ 2.. Length(l) ] do
            tmp  := OrStABProductTwoLists( prod, l[i] );
            prod := tmp.prod;
            for j in [1..Length( prod )] do
                tmp.e[j][1] := e[ tmp.e[j][1] ];
                tmp.e[j]    := Flat( tmp.e[j] );
            od;
            e   := tmp.e;
        od;

    return rec( prod := prod , e := e );

end;

##########################################################
# Given a basis of an abelian p-group and a p-element elm
# the function computes a relation of the form
# elm^(p^k) = \prod_{i=1}^n basis[i]^(d_i)
# returns [ p^k, [d_1,\dots,d_n] ]
##########################################################
RelationMatrixAbelianpGroup := function( basis, elm )

    local   ord,
            p,
            h,
            L1, L2, L3,
            m,
            i,j,
            r,
            l,
            pos;

    if elm = elm^0 then
        l := ListWithIdenticalEntries( Length(basis), 0 );
        return [ 1, l ];
    fi;

    p    := Factors( Order(elm) )[1];
    ord  := List( basis, Order );
    h    := LogInt( Order( elm ), p );

    if IsBool(h) then
        Error( "The new element has non p-order. ");
    fi;

    L1 := []; 
    L2 := [];
    m  := [];
    for i in [1..Length( basis ) ] do
        r := Int( Ceil( Sqrt( Float( ord[i] ) ) ) );
        Add( L1, List( [0..r-1], x-> basis[i]^x ) );
        Add( L2, List( [1..r], x-> basis[i]^( x*r ) ) );
        Add( m, r );
    od;

    L3 := List( [0..h], x -> elm^(p^x) );
    L1 := Concatenation( [ L3 ], L1 );
    L1 := OrStABProductListOfLists( L1 );
    L2 := OrStABProductListOfLists( L2 );

    
    for i in [1.. Length( L1.prod ) ] do

        pos := Position( L2.prod, L1.prod[i] );

        if IsInt( pos ) then
        
            L1 := List( L1.e[i], x -> x-1 ); 
            L2 := L2.e[pos];
            L1[1] := p^(L1[1]);
            
            if IsList( L2 ) then 
                for j in [1.. Length( L2 ) ] do
                    L2[j] := L2[j]*m[j] - L1[j+1];
                od;
            else
                L2 := [ L2 * m[1] - L1[2] ];
            fi;
            return [ L1[1], L2 ];
        fi;
    od;
end;

#############################################################################
# Given a basis of a p-abelian group, a p-element elm and a relation 
# elm^(p^k) = \prod_{i=1}^n basis[i]^(d_i)
# returns a basis of the group generated by basis\cup elm
#############################################################################
BasisRelationAbelianMatpGroup := function( basis, rels, elm )

    local   ord,
            p,
            h,
            k,
            r,
            l,
            gamm,
            t,
            at,
            newr, newb,
            u,
            i;

    if elm = elm^0 then
        return basis;
    fi;

    if ForAll( basis, b -> b = b^0 ) then
        return [ elm ];
    fi;

    ord  := List( basis, Order );
    p    := Factors( Order(elm) )[1];
    h    := LogInt( Order( elm ), p );

    if IsBool(h) then
        Error( "The new element has non p-order. ");
    fi;
    
    k    := LogInt( rels[1], p ); 
    
    if k = 0 then 
        return basis;
    elif k = h then
        newb := ShallowCopy( basis );
        Add( newb, elm );
        return newb;
    fi;

    r    := LogInt( Gcd( Flat( rels ) ), p );
    l    := Length( basis );
    gamm := List( [ 1..l ], i -> rels[2][i]/p^r );
    
    if r = 0 then
        t    := List( [ 1..l ], i -> Gcd( p, gamm[i] ) );
        t    := Position( t, 1 );

        newb := ShallowCopy( basis );
        Remove( newb, t );

        at   := LogInt( ord[t], p );
        newr := ShallowCopy( rels );
        newr[1] := p^(k+at);
        Remove( newr[2], t );
        Remove( ord, t );
        newr[2] := List( [1..l-1], x -> ( newr[2][x]*p^at ) mod ord[x] );

        return BasisRelationAbelianMatpGroup( newb, newr, elm );

    else
        u := elm^(p^(k-r));
        for i in [1..l] do
            u := u * basis[i]^(-gamm[i]);
        od;

        if k = r then
            newb := ShallowCopy( basis );
            Add( newb, u );
            return newb;
        else
            t    := List( [ 1..l ], i -> Gcd( p, gamm[i] ) );
            t    := Position( t, 1 );

            newb := ShallowCopy( basis );
            Remove( newb, t );
            Add( newb, u );

            at   := LogInt( ord[t], p );
            newr := ShallowCopy( rels );
            newr[1] := p^(k-r+at);
            Remove( newr[2], t );
            Remove( ord, t );
            newr[2] := List( [1..l-1], x -> ( newr[2][x]*p^at ) mod ord[x] );

            return BasisRelationAbelianMatpGroup( newb, newr, elm );

        fi;
    fi;

end;

################################################################################
# Given a set of generators of a finite abelian group G returns a basis of G
################################################################################
InstallGlobalFunction( BasisFiniteAbelianMatGroup,
    function( gens )

    local   ord,
            fac,
            P,
            i,
            p,
            exps,
            j,
            n,
            e,
            pos,
            pcomp,
            x,
            R,
            H;

    ord := List( gens, Order );
    
    fac := List( ord, Factors );
    P   := AsSet( Flat(fac) );
    P   := ShallowCopy( P );
    fac := List( fac, Collected );

    for i in [ 1..Length( P ) ] do
        p    := P[i];
        exps := [];
        for j in [ 1..Length( fac ) ] do
            n   := List( fac[j], x -> x[1] );
            e   := List( fac[j], x -> x[2] );

            pos := Position( n , p );
            if IsBool(pos) then
                Add( exps, 0 );
            else
                Add( exps, e[pos] );
            fi;

            P[i] := [ p, exps ];
        od;

    od;

    pcomp := [];
    for p in P do
        x := List( [1..Length( gens )], i -> gens[i]^( ord[i]/ p[1]^p[2][i] ) );
        x := Filtered( x, y -> y <> y^0 );

        H := [ gens[1]^0 ];
        for i in [1..Length( x )] do
            R := RelationMatrixAbelianpGroup( H, x[i] );
            H := BasisRelationAbelianMatpGroup( H, R, x[i] );
        od;

        Add( pcomp, [ p[1], H ] );
    
    od;

    return pcomp;

end );

RelationLatticeFiniteAbelianMat := function( gens )

    local   ord,
            fac,
            P,
            i,
            p,
            exps,
            j,
            n,
            e,
            pos,
            pcomp,
            L,
            x,
            R,
            H;

    ord := List( gens, Order );
    
    fac := List( ord, Factors );
    P   := AsSet( Flat(fac) );
    P   := ShallowCopy( P );
    fac := List( fac, Collected );

    for i in [ 1..Length( P ) ] do
        p    := P[i];
        exps := [];
        for j in [ 1..Length( fac ) ] do
            n   := List( fac[j], x -> x[1] );
            e   := List( fac[j], x -> x[2] );

            pos := Position( n , p );
            if IsBool(pos) then
                Add( exps, 0 );
            else
                Add( exps, e[pos] );
            fi;

            P[i] := [ p, exps ];
        od;

    od;

    pcomp := [];
    L     := [];
    for p in P do
        x := List( [1..Length( gens )], i -> gens[i]^( ord[i]/ p[1]^p[2][i] ) );

        H := [ gens[1]^0 ];
        for i in [1..Length( x )] do
            R := RelationMatrixAbelianpGroup( H, x[i] );
            Add( L, [ p[1], p[2][i], i, R ] );
            H := BasisRelationAbelianMatpGroup( H, R, x[i] );
        od;

        Add( pcomp, [ p[1], H ] );
    
    od;

    return rec( pcomp := pcomp, rellat := L );

end ;